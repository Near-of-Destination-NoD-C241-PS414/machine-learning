# -*- coding: utf-8 -*-
"""NoD_Recommendation CBF Model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1252rNlZVMVTpSIwzgEV1BqX7P-p-Vks7

# **SISTEM REKOMENDASI DESTINASI WISATA NoD (NEAR OF DESTINATION)**


---
Team ID : `C241-PS414`

# Instalasi Libraries
**`Numpy` `Scikit-Learn` `Surprise` `Geodesic` `Pandas` `TensorFlow` `TensorFlowJs`**
"""

# !pip install surprise
# !pip install tensorflow
# !pip install tensorflowjs
# !pip install pydantic-settings
# !pip install pandas-profiling

# Manipulasi dan Analisis Data
# pandas: Untuk manipulasi data dan analisis data.
# numpy: Untuk operasi numerik.
import pandas as pd
import numpy as np
import sklearn

# Visualisasi Data
# seaborn: Untuk visualisasi data statistik.
# matplotlib.pyplot: Untuk membuat plot dan grafik.
import seaborn as sns
import matplotlib.pyplot as plt

# Pembelajaran Mesin
# sklearn.preprocessing: Untuk encoding label dan standarisasi fitur.
# sklearn.model_selection: Untuk membagi dataset menjadi set pelatihan dan set pengujian.
from sklearn.preprocessing import LabelEncoder, StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, mean_absolute_error

# Deep Learning
# tensorflow.keras.models: Untuk membangun dan menyimpan model.
# tensorflow.keras.layers: Untuk membuat lapisan dalam model neural network.
# tensorflow.keras.callbacks: Untuk callback seperti early stopping.
import tensorflow as tf
from tensorflow.keras.models import Model, Sequential, load_model
from tensorflow.keras.layers import Input, Dense, Embedding, Flatten, Concatenate, Dropout
from tensorflow.keras.callbacks import Callback, EarlyStopping
from tensorflow.keras.optimizers import Adam
# Geographical Calculations
# geopy.distance: Untuk menghitung jarak geografis antara koordinat.
from geopy.distance import geodesic

# Profiling dan Pelaporan Data
# ydata_profiling: Untuk membuat laporan profil data secara otomatis.
import ydata_profiling

# Interaksi Sistem dan File
# os: Untuk berinteraksi dengan sistem operasi, seperti membaca daftar file dalam direktori.
# shutil: Untuk mengoperasikan file dan koleksi file.
import os
import shutil

# Google Colab Integration
# google.colab.drive: Untuk mengakses Google Drive dari Colab.
# google.colab.files: Untuk mengunduh file dari Colab.
from google.colab import drive
from google.colab import files

# TensorFlow.js Conversion
# tensorflowjs: Untuk konversi model Keras ke format TensorFlow.js.
import tensorflowjs as tfjs

# Mengimpor warnings dan menonaktifkan pesan peringatan selama eksekusi kode
import warnings
warnings.filterwarnings("ignore")

import folium
from folium.plugins import MarkerCluster

# Menampilkan versi dari setiap library
print("Numpy version:", np.__version__)
print("Scikit-learn version:", sklearn.__version__)
print("Pandas version:", pd.__version__)
print("TensorFlow version:", tf.__version__)
print("TensorFlow.js version:", tfjs.__version__)

"""# Data Wrangling
* **Gathering Data** = Melakukan pengumpulan data serta membaca dataset
* **Assessing Data** = Memeriksa dan memahami data
* **Cleaning Data** = Membersihkan data dari kesalahan/error

## **Gathering Data**
"""

# Mengakses dataset dari Google Drive
drive.mount('/content/drive')
path = "/content/drive/MyDrive/ML"
fnames = os.listdir(path)
print(fnames)

# Load Dataset
NoD = pd.read_csv('/content/drive/MyDrive/ML/NoD.csv')

# Menampilkan informasi ringkas tentang DataFrame
NoD.info()

# Menampilkan beberapa baris pertama dari DataFrame
NoD.head()

"""## **Assessing Data**

### Struktur Data
"""

print(NoD.shape)

"""### Kualitas Data"""

# Nilai yang hilang
print(NoD.isnull().sum())

# Duplikasi
print(NoD.duplicated().sum())

# Ringkasan statistik untuk mendeteksi outlier
print(NoD.describe())

"""### Analisis Statistik Deskriptif"""

# Histogram untuk kolom numerik
NoD.hist(bins=50, figsize=(20, 15))
plt.show()

# Boxplot untuk mendeteksi outlier
sns.boxplot(data=NoD.select_dtypes(include=['float64', 'int64']))
plt.show()

"""### Memahami Konten Data"""

print(NoD['Wilayah'].value_counts())

print(NoD['Provinsi'].value_counts())

print(NoD['Kabupaten/Kota'].value_counts())

print(NoD['Jenis Wisata'].value_counts())

"""### Distribusi Data untuk Setiap Fitur"""

for column in NoD.select_dtypes(include=['float64', 'int64']).columns:
    plt.figure(figsize=(10, 6))
    sns.distplot(NoD[column].dropna(), kde=True)
    plt.title(f'Distribusi dari {column}')
    plt.show()

"""### Analisis Kategorikal"""

plt.figure(figsize=(10, 6))
sns.countplot(data=NoD, x='Jenis Wisata', order=NoD['Jenis Wisata'].value_counts().index)
plt.title('Distribusi Jenis Wisata')
plt.show()

plt.figure(figsize=(10, 6))
sns.barplot(data=NoD, x='Jenis Wisata', y='Rating')
plt.title('Rata-rata Rating per Jenis Wisata')
plt.show()

"""### Analisis Geospasial"""

# Membuat peta dasar
map_ = folium.Map(location=[-8.260630934632104, 115.39061833298781], zoom_start=10)

# Menambahkan titik-titik data ke peta
marker_cluster = MarkerCluster().add_to(map_)
for idx, row in NoD.iterrows():
    folium.Marker(location=[row['Latitude'], row['Longitude']],
                  popup=row['Nama Wisata']).add_to(marker_cluster)

map_

"""### Mengecek Outlier"""

# Menghitung Q1, Q3, dan IQR
Q1 = NoD['Reviews'].quantile(0.25)
Q3 = NoD['Reviews'].quantile(0.75)
IQR = Q3 - Q1

# Mengidentifikasi outlier
outliers_reviews = NoD[((NoD['Reviews'] < (Q1 - 1.5 * IQR)) | (NoD['Reviews'] > (Q3 + 1.5 * IQR)))]

# Mengetahui jumlah data yang outlier
reviews = len(outliers_reviews)
print(f"Jumlah data yang outlier reviews: {reviews}")

"""## Cleaning Data

### Menangani Nilai yang Hilang (Missing Values)
"""

# Menghapus baris yang memiliki nilai yang hilang
NoD.dropna(inplace=True)
print("Jumlah nilai hilang:", NoD.isnull().sum().sum())

"""### Menghapus Duplikasi Data"""

# Menghapus baris yang duplikat
NoD.drop_duplicates(inplace=True)
print("Jumlah nilai duplikat:", NoD.duplicated().sum())

"""### Memperbaiki Ketidakkonsistenan dalam Data"""

# Mengubah teks menjadi huruf kecil
NoD['Nama Wisata'] = NoD['Nama Wisata'].str.lower()

"""### Encoding Fitur Kategorikal"""

# Label Encoding
label_encoder_jenis_wisata = LabelEncoder()
label_encoder_kabupaten_kota = LabelEncoder()
label_encoder_nama_wisata = LabelEncoder()

NoD['Jenis Wisata Encoded'] = label_encoder_jenis_wisata.fit_transform(NoD['Jenis Wisata'])
NoD['Kabupaten/Kota Encoded'] = label_encoder_kabupaten_kota.fit_transform(NoD['Kabupaten/Kota'])
NoD['Nama Wisata Encoded'] = label_encoder_nama_wisata.fit_transform(NoD['Nama Wisata'])

label_mapping_jenis_wisata = dict(zip(label_encoder_jenis_wisata.classes_, label_encoder_jenis_wisata.transform(label_encoder_jenis_wisata.classes_)))
label_mapping_kabupaten_kota = dict(zip(label_encoder_kabupaten_kota.classes_, label_encoder_kabupaten_kota.transform(label_encoder_kabupaten_kota.classes_)))
label_mapping_nama_wisata = dict(zip(label_encoder_nama_wisata.classes_, label_encoder_nama_wisata.transform(label_encoder_nama_wisata.classes_)))

print("\nLabel Mapping Jenis Wisata:")
print(label_mapping_jenis_wisata)

print("\nLabel Mapping Kabupaten/Kota:")
print(label_mapping_kabupaten_kota)

print("\nLabel Mapping Nama Wisata:")
print(label_mapping_nama_wisata)

# Lakukan one-hot encoding pada kolom "Jenis Wisata"
encoded_NoD = pd.get_dummies(NoD['Jenis Wisata'], prefix='Wisata')

# Gabungkan hasil encoding dengan DataFrame asli
NoD_encoded = pd.concat([NoD, encoded_NoD], axis=1)

print(NoD_encoded)

NoD.info()

encoded_NoD.info()

# Gabungkan hasil encoding dengan DataFrame asli
NoD = pd.concat([NoD, encoded_NoD], axis=1)

NoD

"""### Menangani Data yang Tidak Sesuai atau Error"""

# Menampilkan isi data kolom Rating
print(NoD['Rating'])

# Menampilkan baris dengan nilai Rating di luar rentang yang diinginkan
outlier_ratings = NoD.loc[(NoD['Rating'] < 1) | (NoD['Rating'] > 5)]
print(outlier_ratings)

# Menghapus baris dengan nilai yang tidak sesuai
NoD = NoD[NoD['Rating'].between(1, 5)]

# Menampilkan isi data kolom Rating
print(NoD['Rating'])

"""# Save Dataset After Wrangling

Save Model h5
"""

# menyimpan dataframe ke dalam file CSV
NoD.to_csv('NoD_clean.csv', index=False)
NoD_clean = pd.read_csv('./NoD_clean.csv')

"""# Exploratory Data Analysis (EDA)"""

# Assuming NoD is your DataFrame
profile_NoD = ydata_profiling.ProfileReport(NoD)
profile_NoD.to_file("NoD Report.html")

# Menampilkan hasil eksplorasi
profile_NoD

NoD.info()

NoD

"""# Model Content Based Filltering (CBF)

## Model Rekomendasi Berdasarkan Prediksi Jenis Wisata

### Step 1: Hitung Jarak dengan Geodesic
"""

# Hitung jarak dari koordinat pengguna ke semua tempat wisata dalam dataset
def hitung_jarak(user_latitude, user_longitude, NoD_clean):
    jarak = []
    for index, tempat_wisata in NoD_clean.iterrows():
        jarak_tempat_wisata = geodesic((user_latitude, user_longitude), (tempat_wisata['Latitude'], tempat_wisata['Longitude'])).kilometers
        jarak.append(jarak_tempat_wisata)
    NoD_clean['Jarak'] = jarak
    return NoD_clean

# Koordinat pengguna (contoh)
user_latitude, user_longitude = -6.2088, 106.8456

# Hitung jarak
NoD_clean = hitung_jarak(user_latitude, user_longitude, NoD_clean)

NoD_clean

"""### Step 2: Train Model"""

X = NoD_clean[['Kabupaten/Kota Encoded', 'Nama Wisata Encoded', 'Jarak', 'Wisata_Air', 'Wisata_Bukit', 'Wisata_Monumen', 'Wisata_Religi', 'Wisata_Taman']]
Y = NoD_clean['Jenis Wisata Encoded']

X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=42)

# Normalisasi data
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

# Membangun model MLP
def create_model():
    model = Sequential()
    model.add(Dense(128, activation='relu', input_shape=(X_train.shape[1],)))
    model.add(Dropout(0.2))
    model.add(Dense(64, activation='relu'))
    model.add(Dropout(0.2))
    model.add(Dense(32, activation='relu'))
    model.add(Dense(5, activation='softmax'))  # Output layer dengan jumlah neuron sesuai dengan jumlah kelas jenis wisata
    model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])
    return model

model_jenis_wisata = create_model()

# Callbacks
early_stopping = EarlyStopping(monitor='val_loss', patience=10, restore_best_weights=True)

# Melatih model
history = model_jenis_wisata.fit(X_train, Y_train,
                                 validation_split=0.3,
                                 epochs=100,
                                 batch_size=32,
                                 callbacks=[early_stopping])

# Evaluasi model
loss, accuracy = model_jenis_wisata.evaluate(X_test, Y_test)
print("Loss on test data:", loss)
print("Accuracy on test data:", accuracy)

"""### Step 3: Saved Model"""

model_jenis_wisata.save('Recommendation_Jenis_Wisata.h5')
print("Model saved as Recommendation_Jenis_Wisata.h5")
files.download('Recommendation_Jenis_Wisata.h5')

model_jenis_wisata.export('mymodel')

import subprocess
command = [
    'tensorflowjs_converter',
    '--input_format', 'tf_saved_model',
    '--output_format','tfjs_graph_model',
    'mymodel',  # Input Keras model file
    'tfjs_model12'   # Output directory for the TensorFlow.js model
]
subprocess.run(command)

"""### Step 4: Testing Model

#### Rekomendasi Berdasarkan Jenis Wisata
"""

# Load model yang sudah disimpan
model = load_model('Recommendation_Jenis_Wisata.h5')
model_jenis_wisata = model

from geopy.distance import geodesic
import numpy as np

def get_recommendation_by_distance_and_category(model_jenis_wisata, user_latitude, user_longitude, selected_category, NoD_clean):
    # Hitung jarak dari koordinat pengguna ke semua tempat wisata dalam dataset
    def hitung_jarak(user_latitude, user_longitude, NoD_clean):
        jarak = []
        for index, tempat_wisata in NoD_clean.iterrows():
            jarak_tempat_wisata = geodesic((user_latitude, user_longitude), (tempat_wisata['Latitude'], tempat_wisata['Longitude'])).kilometers
            jarak.append(jarak_tempat_wisata)
        NoD_clean['Jarak'] = jarak
        return NoD_clean

    # Hitung jarak
    NoD_clean = hitung_jarak(user_latitude, user_longitude, NoD_clean)

    # Filter tempat wisata berdasarkan jenis wisata yang dipilih pengguna
    filtered_data = NoD_clean[NoD_clean[selected_category] == 1]

    # Normalisasi data
    X_test = filtered_data[['Kabupaten/Kota Encoded', 'Nama Wisata Encoded', 'Jarak', 'Wisata_Air', 'Wisata_Bukit', 'Wisata_Monumen', 'Wisata_Religi', 'Wisata_Taman']]
    X_test_scaled = scaler.transform(X_test)

    # Prediksi jenis wisata
    predicted_category = np.argmax(model_jenis_wisata.predict(X_test_scaled), axis=1)

    # Gabungkan hasil prediksi dengan dataset
    filtered_data['Predicted Category'] = predicted_category

    # Sorting berdasarkan jarak terdekat
    recommended_places = filtered_data.sort_values(by='Jarak').head(15)

    return recommended_places

# Label Mapping Jenis Wisata:
# {'Air': 0, 'Bukit': 1, 'Monumen': 2, 'Religi': 3, 'Taman': 4}

# Contoh penggunaan 1
selected_category = 'Wisata_Taman'
user_latitude, user_longitude = -8.123566881348339, 115.06560150999103  # Koordinat pengguna (contoh)

# Mendapatkan rekomendasi berdasarkan jarak dan jenis wisata pilihan pengguna
recommended_places = get_recommendation_by_distance_and_category(model_jenis_wisata, user_latitude, user_longitude, selected_category, NoD_clean)

# Menampilkan hasil rekomendasi
print(recommended_places[['Kabupaten/Kota', 'Nama Wisata', 'Jenis Wisata', 'Rating', 'Reviews', 'Jarak', 'Predicted Category']])

# Contoh penggunaan 2
selected_category = 'Wisata_Air'
user_latitude, user_longitude = -8.123566881348339, 115.06560150999103  # Koordinat pengguna (contoh)

# Mendapatkan rekomendasi berdasarkan jarak dan jenis wisata pilihan pengguna
recommended_places = get_recommendation_by_distance_and_category(model_jenis_wisata, user_latitude, user_longitude, selected_category, NoD)

# Menampilkan hasil rekomendasi
print(recommended_places[['Kabupaten/Kota', 'Nama Wisata', 'Jenis Wisata', 'Rating', 'Reviews', 'Jarak', 'Predicted Category']])

# Contoh penggunaan 3
selected_category = 'Wisata_Religi'
user_latitude, user_longitude = -8.123566881348339, 115.06560150999103  # Koordinat pengguna (contoh)

# Mendapatkan rekomendasi berdasarkan jarak dan jenis wisata pilihan pengguna
recommended_places = get_recommendation_by_distance_and_category(model_jenis_wisata, user_latitude, user_longitude, selected_category, NoD)

# Menampilkan hasil rekomendasi
print(recommended_places[['Kabupaten/Kota', 'Nama Wisata', 'Jenis Wisata', 'Rating', 'Reviews', 'Jarak', 'Predicted Category']])

"""#### Rekomendasi Berdasarkan Jarak"""

def get_recommendation_by_distance(model_jenis_wisata, user_latitude, user_longitude, NoD_clean):
    # Hitung jarak dari koordinat pengguna ke semua tempat wisata dalam dataset
    def hitung_jarak(user_latitude, user_longitude, NoD_clean):
        jarak = []
        for index, tempat_wisata in NoD_clean.iterrows():
            jarak_tempat_wisata = geodesic((user_latitude, user_longitude), (tempat_wisata['Latitude'], tempat_wisata['Longitude'])).kilometers
            jarak.append(jarak_tempat_wisata)
        NoD_clean['Jarak'] = jarak
        return NoD_clean

    # Hitung jarak
    NoD_clean = hitung_jarak(user_latitude, user_longitude, NoD_clean)

    # Normalisasi data
    X_test = NoD_clean[['Kabupaten/Kota Encoded', 'Nama Wisata Encoded', 'Jarak', 'Wisata_Air', 'Wisata_Bukit', 'Wisata_Monumen', 'Wisata_Religi', 'Wisata_Taman']]
    X_test_scaled = scaler.transform(X_test)

    # Prediksi jenis wisata
    predicted = np.argmax(model_jenis_wisata.predict(X_test_scaled), axis=1)

    # Gabungkan hasil prediksi dengan dataset
    NoD_clean['Predicted Category'] = predicted

    # Sorting berdasarkan jarak terdekat
    recommended_places = NoD_clean.sort_values(by='Jarak').head(15)

    return recommended_places

# Label Mapping Jenis Wisata:
# {'Air': 0, 'Bukit': 1, 'Monumen': 2, 'Religi': 3, 'Taman': 4}

# Contoh penggunaan 1
user_latitude, user_longitude = -8.123566881348339, 115.06560150999103  # Koordinat pengguna (contoh)

# Mendapatkan rekomendasi berdasarkan jarak dan jenis wisata pilihan pengguna
recommended_places = get_recommendation_by_distance(model_jenis_wisata, user_latitude, user_longitude, NoD_clean)

# Menampilkan hasil rekomendasi
print(recommended_places[['Kabupaten/Kota', 'Nama Wisata', 'Jenis Wisata', 'Rating', 'Reviews', 'Jarak', 'Predicted Category']])

# Contoh penggunaan 2
user_latitude, user_longitude = -6.472807961145061, 106.8630118908314  # Koordinat pengguna (contoh)

# Mendapatkan rekomendasi berdasarkan jarak dan jenis wisata pilihan pengguna
recommended_places = get_recommendation_by_distance(model_jenis_wisata, user_latitude, user_longitude, NoD)

# Menampilkan hasil rekomendasi
print(recommended_places[['Kabupaten/Kota', 'Nama Wisata', 'Jenis Wisata', 'Rating', 'Reviews', 'Jarak', 'Predicted Category']])

"""#### Rekomendasi Berdasarkan Reviews"""

def get_recommendation_by_distance_and_reviews(model_jenis_wisata, user_latitude, user_longitude, NoD_clean):
    # Hitung jarak dari koordinat pengguna ke semua tempat wisata dalam dataset
    def hitung_jarak(user_latitude, user_longitude, NoD_clean):
        jarak = []
        for index, tempat_wisata in NoD_clean.iterrows():
            jarak_tempat_wisata = geodesic((user_latitude, user_longitude), (tempat_wisata['Latitude'], tempat_wisata['Longitude'])).kilometers
            jarak.append(jarak_tempat_wisata)
        NoD_clean['Jarak'] = jarak
        return NoD_clean

    # Hitung jarak
    NoD_clean = hitung_jarak(user_latitude, user_longitude, NoD_clean)

    # Sorting berdasarkan jarak terdekat
    recommended_places = NoD_clean.sort_values(by='Jarak').head(15)

    # Urutkan berdasarkan banyaknya ulasan (reviews) secara menurun
    recommended_places = recommended_places.sort_values(by='Reviews', ascending=False)

    return recommended_places

# Contoh penggunaan 1
user_latitude, user_longitude = -8.652998964078941, 115.21385652533104  # Koordinat pengguna (contoh)

# Mendapatkan rekomendasi berdasarkan jarak dan banyaknya ulasan (reviews)
recommended_places = get_recommendation_by_distance_and_reviews(model_jenis_wisata, user_latitude, user_longitude, NoD_clean)

# Menampilkan hasil rekomendasi
print(recommended_places[['Kabupaten/Kota', 'Nama Wisata', 'Jenis Wisata', 'Rating', 'Reviews', 'Jarak']])

# Contoh penggunaan 2
user_latitude, user_longitude = -6.472807961145061, 106.8630118908314  # Koordinat pengguna (contoh)

# Mendapatkan rekomendasi berdasarkan jarak dan jenis wisata pilihan pengguna
recommended_places = get_recommendation_by_distance_and_reviews(model_jenis_wisata, user_latitude, user_longitude, NoD)

# Menampilkan hasil rekomendasi
print(recommended_places[['Kabupaten/Kota', 'Nama Wisata', 'Jenis Wisata', 'Rating', 'Reviews', 'Jarak', 'Predicted Category']])

"""#### Testing by Choose the Recommendation Model"""

def switch_case_test(test_case, model_jenis_wisata, NoD_clean):
    if test_case == 1:
        user_latitude = float(input("Masukkan latitude pengguna: "))
        user_longitude = float(input("Masukkan longitude pengguna: "))
        selected_category = input("Masukkan jenis wisata yang dipilih: ")
        recommended_places = get_recommendation_by_distance_and_category(model_jenis_wisata, user_latitude, user_longitude, selected_category, NoD_clean)
    elif test_case == 2:
        user_latitude = float(input("Masukkan latitude pengguna: "))
        user_longitude = float(input("Masukkan longitude pengguna: "))
        recommended_places = get_recommendation_by_distance(model_jenis_wisata, user_latitude, user_longitude, NoD_clean)
    elif test_case == 3:
        user_latitude = float(input("Masukkan latitude pengguna: "))
        user_longitude = float(input("Masukkan longitude pengguna: "))
        recommended_places = get_recommendation_by_distance_and_reviews(model_jenis_wisata, user_latitude, user_longitude, NoD_clean)
    else:
        print("Invalid test case number. Please choose 1, 2, or 3.")
        return None
    return recommended_places

test_case = int(input("Masukkan nomor test case (1/2/3): "))  # Pilih nomor test case

if isinstance(NoD_clean, pd.DataFrame):
    recommended_places = switch_case_test(test_case, model_jenis_wisata, NoD_clean)
    if recommended_places is not None:
        print(recommended_places[['Kabupaten/Kota', 'Nama Wisata', 'Jenis Wisata', 'Rating', 'Reviews', 'Jarak', 'Predicted Category']])
else:
    print("NoD_clean bukan DataFrame yang valid. Pastikan data telah dimuat dengan benar.")

test_case = int(input("Masukkan nomor test case (1/2/3): "))  # Pilih nomor test case

if isinstance(NoD_clean, pd.DataFrame):
    recommended_places = switch_case_test(test_case, model_jenis_wisata, NoD_clean)
    if recommended_places is not None:
        print(recommended_places[['Kabupaten/Kota', 'Nama Wisata', 'Jenis Wisata', 'Rating', 'Reviews', 'Jarak', 'Predicted Category']])
else:
    print("NoD_clean bukan DataFrame yang valid. Pastikan data telah dimuat dengan benar.")

test_case = int(input("Masukkan nomor test case (1/2/3): "))  # Pilih nomor test case

if isinstance(NoD_clean, pd.DataFrame):
    recommended_places = switch_case_test(test_case, model_jenis_wisata, NoD_clean)
    if recommended_places is not None:
        print(recommended_places[['Kabupaten/Kota', 'Nama Wisata', 'Jenis Wisata', 'Rating', 'Reviews', 'Jarak', 'Predicted Category']])
else:
    print("NoD_clean bukan DataFrame yang valid. Pastikan data telah dimuat dengan benar.")